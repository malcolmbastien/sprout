---
import { getCollection, type CollectionEntry } from "astro:content";
import Layout from "../layouts/Layout.astro";
import ActivityHeatmap from "../components/Profile/ActivityHeatmap.astro";
import ProfileHeader from "../components/Profile/ProfileHeader.astro";
import YearNavigation from "../components/YearNavigation.astro";
import NoteTimeline from "../components/NoteTimeline.astro";
import SiteFooter from "../components/SiteFooter.astro";
import { getStageColors } from "../lib/theme";
import { getBatchFileDates, type FileDates } from "../lib/git-history";

const allNotes = await getCollection("notes");
const batchDates = (await getBatchFileDates()) as Map<string, FileDates>;
const stageColors = getStageColors();

// Fetch git dates for all notes to create timeline events
const notesWithDates = allNotes.map((note) => {
    const id = note.id;
    const dates = batchDates.get(`src/content/notes/${id}`) ||
                  batchDates.get(`src/content/notes/${id}.md`) ||
                  batchDates.get(`src/content/notes/${id}.mdx`);

    const created = dates?.created;
    const allGitDates = dates?.allDates || new Set<string>();

    const displayDate = note.data.publishedDate || created;

    return {
        ...note,
        displayDate,
        allGitDates,
    };
}).filter(note => note.displayDate); // Only show notes that have a valid date from frontmatter or git

// Create timeline events
const events: any[] = [];
notesWithDates.forEach((note) => {
    const displayDate = note.displayDate as Date;
    const displayDateStr = displayDate.toISOString().split("T")[0];

    // Add creation event
    events.push({
        type: "created",
        note,
        date: displayDate,
        title: note.data.title,
    });

    // Add update events for all other unique git dates
    note.allGitDates.forEach((dateStr: string) => {
        // Only add as update if it's a different day than creation
        if (dateStr !== displayDateStr) {
            // We use 12:00 PM for these historical updates to ensure they sort reasonably
            // or we could try to find the actual time, but dateStr is just the day
            const updateDate = new Date(dateStr + "T12:00:00");
            events.push({
                type: "updated",
                note,
                date: updateDate,
                title: note.data.title,
            });
        }
    });
});

// Aggregate events: group multiple updates to same note within short time
const aggregatedEvents: any[] = [];
const eventGroups = new Map();

events.forEach((event) => {
    // Group by slug, type, AND date (day) to ensure at most one event per note per day per type
    const dateStr = (event.date as Date).toISOString().split("T")[0];
    const key = `${event.note.slug}-${event.type}-${dateStr}`;
    if (!eventGroups.has(key)) {
        eventGroups.set(key, []);
    }
    eventGroups.get(key).push(event);
});

eventGroups.forEach((group) => {
    if (group.length === 1) {
        aggregatedEvents.push(group[0]);
    } else {
        // Multiple events, aggregate them
        const firstEvent = group[0];
        const lastEvent = group[group.length - 1];
        aggregatedEvents.push({
            ...firstEvent,
            count: group.length,
            date: lastEvent.date, // Use the most recent date
        });
    }
});

// Sort events by date descending
const sortedEvents = aggregatedEvents.sort(
    (a, b) => b.date.valueOf() - a.date.valueOf(),
);

// Identify which events to collapse in the timeline (show only one update per note per month)
const creationsInMonth = new Set<string>();
sortedEvents.forEach((e) => {
    if (e.type === "created") {
        const monthKey = e.date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
        });
        creationsInMonth.add(`${e.note.slug}-${monthKey}`);
    }
});

const seenUpdateInMonth = new Set<string>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    const noteKey = `${event.note.slug}-${monthKey}`;

    if (event.type === "created") {
        event.isCollapsed = false;
    } else {
        // It's an update - collapse if there's a creation or a later update in the same month
        if (creationsInMonth.has(noteKey) || seenUpdateInMonth.has(noteKey)) {
            event.isCollapsed = true;
        } else {
            event.isCollapsed = false;
            seenUpdateInMonth.add(noteKey);
        }
    }
});

// Generate all months from earliest event to now
const earliestDate =
    sortedEvents.length > 0
        ? sortedEvents[sortedEvents.length - 1]?.date || new Date()
        : new Date();
const latestDate =
    sortedEvents.length > 0 ? sortedEvents[0]?.date || new Date() : new Date();

const allMonths: Array<{
    key: string;
    date: Date;
    hasActivity: boolean;
}> = [];

const currentDate = new Date();
currentDate.setDate(1); // Start from first day of current month
currentDate.setHours(0, 0, 0, 0);

const endDate = new Date(earliestDate);
endDate.setDate(1);
endDate.setHours(0, 0, 0, 0);

// Group events by month for quick lookup
const eventsByMonthKey = new Map<string, any[]>();
sortedEvents.forEach((event) => {
    const monthKey = event.date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    if (!eventsByMonthKey.has(monthKey)) {
        eventsByMonthKey.set(monthKey, []);
    }
    eventsByMonthKey.get(monthKey)?.push(event);
});

// Generate all months from current to earliest
while (currentDate >= endDate) {
    const monthKey = currentDate.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
    });
    allMonths.push({
        key: monthKey,
        date: new Date(currentDate),
        hasActivity: eventsByMonthKey.has(monthKey),
    });

    // Move to previous month
    currentDate.setMonth(currentDate.getMonth() - 1);
}

// Collect years data for sidebar
const yearsData = new Map();
sortedEvents.forEach((event) => {
    const year = event.date.getFullYear();
    const month = event.date.getMonth();

    if (!yearsData.has(year)) {
        yearsData.set(year, { count: 0, months: new Set(), uniqueNotes: new Set() });
    }
    yearsData.get(year).count++; // Total activity for dots
    yearsData.get(year).months.add(month);
    yearsData.get(year).uniqueNotes.add(event.note.id); // Unique notes for the count label
});

// Convert to array and sort by year descending
const yearsArray = Array.from(yearsData.entries());
yearsArray.sort((a, b) => b[0] - a[0]);
const sortedYears = yearsArray.map(([year, data]) => ({
    year: year as number,
    count: data.uniqueNotes.size, // Number of unique notes touched
    activityCount: data.count as number, // Total activity volume
    months: (Array.from(data.months) as number[]).sort((a, b) => b - a), // months descending within year
}));

// Identify pinned notes
const pinnedNotes = allNotes.filter((note) => (note.data as any).pinned === true);

// Get latest 3 created notes (that aren't pinned)
const latestCreations = notesWithDates
    .filter(p => !pinnedNotes.some(pinned => pinned.id === p.id))
    .sort((a, b) => (b.displayDate as Date).valueOf() - (a.displayDate as Date).valueOf())
    .slice(0, 3);

// Default to current year for heatmap
const currentYearValue = new Date().getFullYear();
---



<Layout
    title="Sprout - A Digital Garden"
    description="A digital garden of thoughts and ideas. Explore seeds, sprouts, and evergreens of knowledge in this ever-growing collection of writings."
    type="website"
>
    <style slot="head" is:inline set:html={
        sortedYears.map(y => `
        /* Instant CSS-driven filtering */
        html[data-selected-year="${y.year}"] .timeline-event:not([data-event-year="${y.year}"]),
        html[data-selected-year="${y.year}"] .month-section:not([data-year="${y.year}"]) {
            display: none !important;
        }

        /* Initial batching protection (before JS takes over) */
        html:not(.js-initialized)[data-selected-year="${y.year}"] .timeline-event[data-event-year="${y.year}"][data-is-initial-batch="false"] {
            display: none !important;
        }
        html:not(.js-initialized)[data-selected-year="${y.year}"] .month-section[data-year="${y.year}"]:not(:has(.timeline-event[data-event-year="${y.year}"][data-is-initial-batch="true"])) {
            display: none !important;
        }
        
        /* Instant Sidebar Highlighting */
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] {
            background-color: #059669;
            color: white;
            border-color: #0f172a !important;
        }
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] span.text-slate-500 {
            color: rgba(255, 255, 255, 0.9);
        }
        html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] .activity-dots div {
            background-color: rgba(255, 255, 255, 0.4);
        }
        .dark html[data-selected-year="${y.year}"] .year-btn[data-year="${y.year}"] {
            background-color: #10b981;
        }
        html[data-selected-year="${y.year}"] .year-item:has(.year-btn[data-year="${y.year}"]) .month-submenu {
            display: block !important;
        }
        `).join('')
    } />
    <script slot="head" is:inline>
        // Set the selected year as early as possible in the HEAD to allow for CSS-driven filtering
        (function() {
            const savedYear = localStorage.getItem('selectedYear');
            const currentYear = new Date().getFullYear().toString();
            document.documentElement.setAttribute('data-selected-year', savedYear || currentYear);
        })();
    </script>
    <main class="max-w-7xl mx-auto p-4 md:p-8" data-pagefind-ignore>
        <ProfileHeader />

        {
            pinnedNotes.length > 0 && (
                <div class="mb-12">
                    <div class="flex items-center gap-2 mb-4">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5 text-emerald-500"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                        >
                            <path
                                fill-rule="evenodd"
                                d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z"
                                clip-rule="evenodd"
                            />
                        </svg>
                        <h2 class="text-sm font-bold uppercase tracking-widest text-slate-500 dark:text-slate-400">
                            Pinned Notes
                        </h2>
                    </div>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        {pinnedNotes.map((note) => (
                            <a
                                href={`/notes/${note.id}`}
                                class="group block p-5 bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-2xl shadow-xs hover:border-emerald-500/50 hover:shadow-md transition-all relative overflow-hidden"
                            >
                                <div class="absolute top-0 right-0 p-3 opacity-20 group-hover:opacity-100 transition-opacity">
                                    <span class="text-xs">ðŸ“Œ</span>
                                </div>
                                <h3 class="text-lg font-bold text-slate-900 dark:text-white mb-2 group-hover:text-emerald-600 dark:group-hover:text-emerald-400 transition-colors">
                                    {note.data.title}
                                </h3>
                                {note.data.summary && (
                                    <p class="text-sm text-slate-600 dark:text-slate-400 line-clamp-2">
                                        {note.data.summary}
                                    </p>
                                )}
                                <div class="mt-4 flex items-center gap-3">
                                    <span class={`text-[10px] font-bold uppercase tracking-wider px-1.5 py-0.5 rounded ${stageColors[note.data.stage as keyof typeof stageColors]}`}>
                                        {note.data.stage === "seed" ? "ðŸŒ±" : note.data.stage === "sprout" ? "ðŸŒ¿" : "ðŸŒ²"} {note.data.stage}
                                    </span>
                                    {note.data.tags.slice(0, 2).map((tag: string) => (
                                        <span class="text-[10px] text-slate-400 dark:text-slate-500 font-medium">
                                            #{tag}
                                        </span>
                                    ))}
                                </div>
                            </a>
                        ))}
                    </div>
                </div>
            )
        }

        {
            latestCreations.length > 0 && (
                <div class="mb-12">
                    <div class="flex items-center gap-2 mb-4">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5 text-emerald-500"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                        >
                            <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" />
                        </svg>
                        <h2 class="text-sm font-bold uppercase tracking-widest text-slate-500 dark:text-slate-400">
                            Freshly Planted
                        </h2>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        {latestCreations.map((note) => (
                            <a
                                href={`/notes/${note.id}`}
                                class="group block p-4 bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl hover:border-emerald-500/30 transition-all"
                            >
                                <div class="flex items-center justify-between mb-2">
                                    <span class="text-[10px] font-bold uppercase tracking-wider text-emerald-600 dark:text-emerald-400">
                                        {note.displayDate?.toLocaleDateString("en-US", { month: 'short', day: 'numeric' })}
                                    </span>
                                    <span class={`text-[10px] px-1.5 py-0.5 rounded font-bold uppercase tracking-wider ${stageColors[note.data.stage as keyof typeof stageColors]}`}>
                                        {note.data.stage === "seed" ? "ðŸŒ±" : note.data.stage === "sprout" ? "ðŸŒ¿" : "ðŸŒ²"} {note.data.stage}
                                    </span>
                                </div>
                                <h3 class="text-base font-bold text-slate-900 dark:text-white mb-1 group-hover:text-emerald-600 dark:group-hover:text-emerald-400 transition-colors line-clamp-1">
                                    {note.data.title}
                                </h3>
                                {note.data.summary && (
                                    <p class="text-xs text-slate-500 dark:text-slate-400 line-clamp-2 leading-relaxed">
                                        {note.data.summary}
                                    </p>
                                )}
                            </a>
                        ))}
                    </div>
                </div>
            )
        }

        <div class="grid grid-cols-1 lg:grid-cols-[minmax(0,1fr)_16rem] gap-8">
            <!-- Right Column: Navigation & Search (Moved up to load first and avoid layout shift) -->
            <div class="lg:sticky lg:top-8 h-fit z-30 pb-10 order-last">
                <!-- Search Button -->
                <div class="mb-6">
                    <a
                        href="/search"
                        class="flex items-center gap-3 w-full px-4 py-3 bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl text-slate-500 dark:text-slate-400 hover:border-emerald-500/50 hover:text-emerald-600 transition-all shadow-sm group"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5 text-slate-400 group-hover:text-emerald-500 transition-colors"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            ></path>
                        </svg>
                        <span class="text-sm font-medium">Search garden...</span>
                    </a>
                </div>

                <!-- Years Navigation (Scrollable if long) -->
                <div class="lg:max-h-[calc(100vh-12rem)] lg:overflow-y-auto custom-sidebar-scroll">
                    <YearNavigation sortedYears={sortedYears as any} />
                </div>
            </div>

            <!-- Left Column: Activity Heatmap and Timeline -->
            <div class="space-y-6">
                <ActivityHeatmap
                    year={currentYearValue}
                    events={sortedEvents as any}
                />
                <NoteTimeline
                    sortedEvents={sortedEvents}
                    allMonths={allMonths}
                    eventsByMonthKey={eventsByMonthKey}
                    initialYear={currentYearValue.toString()}
                />
            </div>
        </div>
        <SiteFooter />
    </main>
</Layout>

<style is:global>
    @reference "../styles/global.css";

    /* Styling for the scrollable sidebar */
    .custom-sidebar-scroll {
        scrollbar-width: thin;
        scrollbar-color: #e2e8f0 transparent;
    }
    .dark .custom-sidebar-scroll {
        scrollbar-color: #1e293b transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar {
        width: 4px;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-track {
        background: transparent;
    }
    .custom-sidebar-scroll::-webkit-scrollbar-thumb {
        @apply bg-slate-200 dark:bg-slate-800 rounded-full;
    }

    /* CSS-driven filtering for instant load */
    .timeline-event.hidden-by-filter {
        display: none !important;
    }
</style>

<script>
    declare global {
        interface Window {
            updateHeatmapYear?: (year: number) => void;
        }
    }

    const buttons = document.querySelectorAll("[data-stage]");
    const topicButtons = document.querySelectorAll("[data-topic]");
    const eventTypeButtons = document.querySelectorAll("[data-event-type]");
    const timelineEvents = document.querySelectorAll(".timeline-event");
    const noResults = document.getElementById("no-results");

    // Prevent browser from automatically restoring scroll position which can cause jumps
    // when we dynamically filter content on load.
    if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
    }

    let currentFilter = "all";
    let currentTopic = "";
    let currentEventType = "all";
    let currentYear = document.documentElement.getAttribute('data-selected-year') || new Date().getFullYear().toString();
    let currentDateFilter: string | null = null;
    let itemsToShow = 10;

    const showMoreButton = document.getElementById("show-more-activity");

    function updateDisplay() {
        let totalMatchingCount = 0;
        let visibleCount = 0;

        // Re-query to include dynamically added events
        const allTimelineEvents = document.querySelectorAll(".timeline-event");

        allTimelineEvents.forEach((event) => {
            const htmlEvent = event as HTMLElement;
            const stage = htmlEvent.dataset.stage; // This likely needs to be updated in NoteTimeline component which generates this HTML
            const eventYear = htmlEvent.dataset.eventYear || "";
            const eventType = htmlEvent.dataset.eventType;

            const matchesFilter =
                currentFilter === "all" || stage === currentFilter;
            const matchesTopic = currentTopic === "" || (htmlEvent.dataset.topics || "").includes(currentTopic);
            const matchesEventType =
                currentEventType === "all" || eventType === currentEventType;
            
            // Year matching is now handled by CSS for the initial paint, 
            // but we keep this check for the "totalMatchingCount" and "Show More" logic.
            const matchesYear =
                currentYear === "all" || eventYear === currentYear;

            const isCollapsed = htmlEvent.dataset.isCollapsed === "true";

            // If filtering by a specific date from the heatmap
            const eventDate = htmlEvent.dataset.created || "";
            const matchesDate =
                currentDateFilter === null || eventDate === currentDateFilter;

            // Logic:
            // 1. If we have a specific date filter, show the event if it matches the date, even if collapsed
            // 2. If no date filter, hide collapsed events
            const visibilityByCollapse = currentDateFilter !== null ? matchesDate : !isCollapsed;

            if (
                matchesFilter &&
                matchesTopic &&
                matchesEventType &&
                matchesYear &&
                visibilityByCollapse
            ) {
                totalMatchingCount++;
                if (visibleCount < itemsToShow) {
                    htmlEvent.classList.remove("hidden-by-filter");
                    visibleCount++;
                } else {
                    htmlEvent.classList.add("hidden-by-filter");
                }
            } else {
                htmlEvent.classList.add("hidden-by-filter");
            }
        });

        // Show/hide month sections based on their visible events
        document.querySelectorAll(".month-section").forEach((section) => {
            const htmlSection = section as HTMLElement;
            const eventsInSection = Array.from(
                htmlSection.querySelectorAll(".timeline-event"),
            );
            const hasVisibleEvent = eventsInSection.some(
                (e) => !(e as HTMLElement).classList.contains("hidden-by-filter")
            );

            if (hasVisibleEvent) {
                htmlSection.style.display = "block";
            } else {
                htmlSection.style.display = "none";
            }
        });

        // Update "Show more" button
        if (showMoreButton) {
            if (totalMatchingCount > itemsToShow) {
                showMoreButton.classList.remove("hidden");
                showMoreButton.textContent = `Show more activity (${totalMatchingCount - itemsToShow} remaining)`;
            } else {
                showMoreButton.classList.add("hidden");
            }
        }

        if (noResults) {
            if (totalMatchingCount === 0) noResults.classList.remove("hidden");
            else noResults.classList.add("hidden");
        }
    }

    if (showMoreButton) {
        showMoreButton.addEventListener("click", () => {
            itemsToShow += 10;
            updateDisplay();
        });
    }

    eventTypeButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const eventType =
                (button as HTMLElement).dataset.eventType || "all";
            itemsToShow = 10;
            if (currentEventType === eventType) {
                button.classList.remove("active");
                currentEventType = "all";
            } else {
                eventTypeButtons.forEach((btn) =>
                    btn.classList.remove("active"),
                );
                button.classList.add("active");
                currentEventType = eventType;
            }
            updateDisplay();
        });
    });

    // Year and Month navigation
    const yearButtons = document.querySelectorAll(".year-btn");
    const monthButtons = document.querySelectorAll(".month-btn");

    function selectYear(year: string, button: HTMLElement, isManualClick: boolean = false) {
        const yearItem = button.closest(".year-item") as HTMLElement;
        const monthSubmenu = yearItem?.querySelector(
            ".month-submenu",
        ) as HTMLElement;

        itemsToShow = 10;

        // Update the data attribute for CSS filtering (instant highlighting/hiding)
        document.documentElement.setAttribute('data-selected-year', year);

        if (currentYear === year) {
            if (monthSubmenu && isManualClick) {
                // If it's a manual click on the same year, we toggle the submenu
                // But we check if it was previously forced visible by CSS or JS
                monthSubmenu.classList.toggle("hidden");
            }
        } else {
            // Note: .active class removal is still done for manual clicks to clean up 
            // any JS-applied states, though CSS attribute handles most styling now.
            yearButtons.forEach((btn) => {
                btn.classList.remove("active");
                const item = btn.closest(".year-item");
                const submenu = item?.querySelector(".month-submenu");
                if (submenu) submenu.classList.add("hidden");
            });
            
            // We set the variable but let the [data-selected-year] handle the UI
            currentYear = year;

            if (window.updateHeatmapYear) {
                window.updateHeatmapYear(parseInt(year));
            }
        }
        updateDisplay();
    }

    yearButtons.forEach((button) => {
        button.addEventListener("click", (event) => {
            const year = (button as HTMLElement).dataset.year || "all";
            
            // Preserve the selected year in local storage
            localStorage.setItem('selectedYear', year);
            
            selectYear(year, button as HTMLElement, event.isTrusted);
        });
    });

    monthButtons.forEach((button) => {
        button.addEventListener("click", () => {
            const monthKey = (button as HTMLElement).dataset.month || "";
            const year = (button as HTMLElement).dataset.year || "all";

            itemsToShow = 500; // Increase limit to ensure month content is visible

            if (currentYear !== year) {
                localStorage.setItem('selectedYear', year);
                const yearBtn = document.querySelector(
                    `.year-btn[data-year="${year}"]`,
                ) as HTMLElement;
                if (yearBtn) selectYear(year, yearBtn, false);
            }

            updateDisplay();

            // Scroll to the selected month section
            setTimeout(() => {
                const monthSection = document.querySelector(
                    `.month-section[data-month="${monthKey}"]`,
                );
                if (monthSection) {
                    monthSection.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                    });
                }
            }, 10);
        });
    });

    // Listen for date filter changes from activity heatmap
    window.addEventListener("dateFilterChange", (e: any) => {
        currentDateFilter = e.detail.date;
        itemsToShow = 10;
        updateDisplay();
    });

    // Listen for display updates when new months are revealed
    window.addEventListener("updateDisplayNeeded", () => {
        updateDisplay();
    });

    // Prevent any interference with timeline event clicks
    document.querySelectorAll(".timeline-event").forEach((event) => {
        event.addEventListener(
            "click",
            (e) => {
                e.stopPropagation();
            },
            true,
        );
        event.addEventListener("focus", (e) => e.stopPropagation(), true);
        event.addEventListener("blur", (e) => e.stopPropagation(), true);
    });

    // Automatically select current year or preserved year on initial load
    // We run this immediately because the script is at the bottom of the body
    const initYearSelection = () => {
        const savedYear = localStorage.getItem('selectedYear');
        const currentYearStr = new Date().getFullYear().toString();
        const yearToSelect = savedYear || currentYearStr;

        let yearBtn = document.querySelector(
            `.year-btn[data-year="${yearToSelect}"]`,
        ) as HTMLElement;

        // If saved year button doesn't exist anymore, fallback to current year
        if (!yearBtn && savedYear) {
            yearBtn = document.querySelector(
                `.year-btn[data-year="${currentYearStr}"]`,
            ) as HTMLElement;
        }

        if (yearBtn) {
            selectYear(yearBtn.dataset.year || currentYearStr, yearBtn, false);
        } else {
            const allYearBtns = document.querySelectorAll(".year-btn");
            if (allYearBtns.length > 0) {
                const firstBtn = allYearBtns[0] as HTMLElement;
                selectYear(firstBtn.dataset.year || currentYearStr, firstBtn, false);
            }
        }

        // Handover: Signaling that JS is ready to handle filtering.
        // This removes the "initial batch" CSS restriction.
        document.documentElement.classList.add('js-initialized');
    };

    initYearSelection();
</script>
