---
interface Props {
    year: number;
    events: Array<{
        type: string;
        post: any;
        date: Date;
        title: string;
        count?: number;
    }>;
}

const { year, events } = Astro.props;

// Count activity per day from events (using displayDate which is publishedDate or git date)
const activityMap: Record<string, number> = {};
events.forEach((event) => {
    const dateStr = event.date.toISOString().split("T")[0];
    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
});

interface DayData {
    date: string;
    count: number;
}

interface MonthLabel {
    name: string;
    weekIndex: number;
}

// Generate all days for the specified year (January 1 to December 31)
const days: (DayData | null)[] = [];
const startDate = new Date(year, 0, 1); // January 1st
const endDate = new Date(year, 11, 31); // December 31st

// Add padding for the first week so the grid always starts on Sunday
const startPadding = startDate.getDay(); // 0 is Sunday, 1 is Monday...
for (let i = 0; i < startPadding; i++) {
    days.push(null);
}

for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
    const dateStr = d.toISOString().split("T")[0];
    days.push({
        date: dateStr,
        count: activityMap[dateStr] || 0,
    });
}

// Generate month labels for the year
const monthLabels: MonthLabel[] = [];
let lastMonth = "";
for (let i = 0; i < days.length; i++) {
    const dayData = days[i];
    if (!dayData) continue;

    const d = new Date(dayData.date);
    const monthKey = d.toLocaleDateString("en-US", { month: "short" });
    if (monthKey !== lastMonth) {
        const weekIndex = Math.floor(i / 7);
        // Only include months that are actually in this year and not too close to end
        if (d.getFullYear() === year && weekIndex < 52) {
            monthLabels.push({
                name: monthKey,
                weekIndex: weekIndex,
            });
        }
        lastMonth = monthKey;
    }
}

function getColor(count: number) {
    if (count === 0) return "fill-slate-100 dark:fill-[#1a241a]";
    if (count === 1) return "fill-emerald-200 dark:fill-emerald-900/40";
    if (count === 2) return "fill-emerald-400 dark:fill-emerald-700";
    if (count >= 3) return "fill-emerald-600 dark:fill-emerald-500";
    return "fill-slate-100 dark:fill-[#1a241a]";
}

function getFillColor(count: number, isDarkMode: boolean) {
    // Light mode colors (based on getColor)
    if (!isDarkMode) {
        if (count === 0) return "#f1f5f9"; // slate-100
        if (count === 1) return "#a7f3d0"; // emerald-200
        if (count === 2) return "#34d399"; // emerald-400
        if (count >= 3) return "#059669"; // emerald-600
        return "#f1f5f9";
    }
    // Dark mode colors
    if (count === 0) return "#1a241a";
    if (count === 1) return "#064e3b66"; // emerald-900/40
    if (count === 2) return "#15803d"; // emerald-700
    if (count >= 3) return "#10b981"; // emerald-500
    return "#1a241a";
}

// Keep the original getColor function for static rendering
---

<div
    id="activity-heatmap"
    class="relative bg-white dark:bg-[#121812] border border-slate-200 dark:border-slate-800 rounded-xl p-4 mb-2"
>
    <div
        id="heatmap-tooltip"
        class="fixed hidden z-50 px-2 py-1 text-[11px] font-medium text-white bg-slate-900 dark:bg-slate-800 rounded shadow-md pointer-events-none whitespace-nowrap transition-opacity duration-200"
    >
    </div>
    <div class="flex items-center justify-between mb-4">
        <h3 class="text-sm font-semibold text-slate-900 dark:text-slate-100">
            Activity
        </h3>
        <span
            id="heatmap-year-display"
            class="text-sm font-bold text-emerald-600 dark:text-emerald-400"
        >
            {year}
        </span>
    </div>
    <div class="overflow-x-auto pb-2 custom-scrollbar">
        <svg
            viewBox="0 0 780 125"
            preserveAspectRatio="xMinYMin meet"
            class="w-full activity-heatmap-svg min-w-[700px]"
        >
            <!-- Day labels -->
            <text x="0" y="33" class="fill-slate-400 dark:fill-slate-500 text-[9px] font-medium">Sun</text>
            <text x="0" y="59" class="fill-slate-400 dark:fill-slate-500 text-[9px] font-medium">Tue</text>
            <text x="0" y="85" class="fill-slate-400 dark:fill-slate-500 text-[9px] font-medium">Thu</text>
            <text x="0" y="111" class="fill-slate-400 dark:fill-slate-500 text-[9px] font-medium">Sat</text>

            {
                monthLabels.map((label) => (
                    <text
                        x={label.weekIndex * 14 + 30}
                        y="12"
                        text-anchor="start"
                        class="fill-slate-500 dark:fill-slate-400 text-[10px] font-medium"
                    >
                        {label.name}
                    </text>
                ))
            }
            {
                Array.from({ length: Math.ceil(days.length / 7) }).map(
                    (_, weekIndex) => (
                        <g transform={`translate(${weekIndex * 14 + 30}, 24)`}>
                            {Array.from({ length: 7 }).map((_, dayIndex) => {
                                const dayData = days[weekIndex * 7 + dayIndex];
                                if (!dayData) return null;
                                return (
                                    <rect
                                        x="0"
                                        y={dayIndex * 13}
                                        width="12"
                                        height="12"
                                        rx="2"
                                        class={`${getColor(dayData.count)} activity-day transition-colors duration-300 hover:stroke-slate-400 dark:hover:stroke-slate-500 hover:stroke-1 ${dayData.count > 0 ? "cursor-pointer" : ""}`}
                                        data-date={dayData.date}
                                        data-count={dayData.count}
                                        onclick={
                                            dayData.count > 0
                                                ? `filterByDate('${dayData.date}')`
                                                : undefined
                                        }
                                    />
                                );
                            })}
                        </g>
                    ),
                )
            }
        </svg>
    </div>
    <div
        class="mt-4 flex items-center justify-end gap-2 text-[10px] text-slate-400 uppercase tracking-widest"
    >
        <span>Less</span>
        <div class="w-4 h-4 bg-slate-100 dark:bg-[#1a241a] rounded-xs"></div>
        <div class="w-4 h-4 bg-emerald-200 dark:bg-emerald-900/40 rounded-xs">
        </div>
        <div class="w-4 h-4 bg-emerald-400 dark:bg-emerald-700 rounded-xs">
        </div>
        <div class="w-4 h-4 bg-emerald-600 dark:bg-emerald-500 rounded-xs">
        </div>
        <span>More</span>
    </div>

    <script define:vars={{ events, year }}>
        // Store the currently selected date and year
        let selectedDate = null;
        
        // Initialize currentYear to the year provided by the server.
        // This MUST match what was rendered in the HTML initially.
        let currentYear = year;

        // Function to get Tailwind classes for colors
        function getColor(count) {
            if (count === 0) return "fill-slate-100 dark:fill-[#1a241a]";
            if (count === 1) return "fill-emerald-200 dark:fill-emerald-900/40";
            if (count === 2) return "fill-emerald-400 dark:fill-emerald-700";
            if (count >= 3) return "fill-emerald-600 dark:fill-emerald-500";
            return "fill-slate-100 dark:fill-[#1a241a]";
        }

        // Function to update heatmap for a specific year
        window.updateHeatmapYear = function (newYear) {
            if (currentYear === newYear) return;
            currentYear = newYear;

            // Update year display
            const yearDisplay = document.getElementById("heatmap-year-display");
            if (yearDisplay) {
                yearDisplay.textContent = String(newYear);
            }

            // Clear selected date when changing years
            selectedDate = null;
            const heatmap = document.getElementById("activity-heatmap");
            heatmap?.classList.remove("is-filtering");

            const event = new CustomEvent("dateFilterChange", {
                detail: { date: null },
            });
            window.dispatchEvent(event);

            // Generate new data for year
            const activityMap = {};
            events.forEach((event) => {
                // event.date is serialized as string, convert back to Date
                const eventDate = new Date(event.date);
                const eventYear = eventDate.getFullYear();
                if (eventYear === newYear) {
                    const dateStr = eventDate.toISOString().split("T")[0];
                    activityMap[dateStr] = (activityMap[dateStr] || 0) + 1;
                }
            });

            // Generate all days for year - match format from commits
            const days = [];
            const startDate = new Date(newYear, 0, 1);
            const endDate = new Date(newYear, 11, 31);

            // Add padding for the first week so the grid always starts on Sunday
            const startPadding = startDate.getDay();
            for (let i = 0; i < startPadding; i++) {
                days.push(null);
            }

            for (
                let d = new Date(startDate);
                d <= endDate;
                d.setDate(d.getDate() + 1)
            ) {
                const dateStr = d.toISOString().split("T")[0];
                days.push({
                    date: dateStr,
                    count: activityMap[dateStr] || 0,
                });
            }

            // Update SVG - rebuild everything for new year
            const svg = document.querySelector(".activity-heatmap-svg");
            if (!svg) return;

            // Clear SVG content completely
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            // Add day labels to SVG
            const dayLabels = [
                { name: "Sun", y: 33 },
                { name: "Tue", y: 59 },
                { name: "Thu", y: 85 },
                { name: "Sat", y: 111 }
            ];

            dayLabels.forEach(label => {
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute("x", "0");
                text.setAttribute("y", String(label.y));
                text.setAttribute("class", "fill-slate-400 dark:fill-slate-500");
                text.setAttribute("font-size", "9px");
                text.setAttribute("font-weight", "500");
                text.textContent = label.name;
                svg.appendChild(text);
            });

            // Rebuild month labels
            const monthLabels = [];
            let lastMonth = "";
            const isDarkMode =
                document.documentElement.classList.contains("dark");

            for (let i = 0; i < days.length; i++) {
                const dayData = days[i];
                if (!dayData) continue;

                const d = new Date(dayData.date);
                const monthKey = d.toLocaleDateString("en-US", {
                    month: "short",
                });
                if (monthKey !== lastMonth) {
                    const weekIndex = Math.floor(i / 7);
                    if (d.getFullYear() === newYear && weekIndex < 52) {
                        monthLabels.push({
                            name: monthKey,
                            weekIndex: weekIndex,
                        });
                    }
                    lastMonth = monthKey;
                }
            }

            // Add month labels to SVG
            monthLabels.forEach((label) => {
                const text = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "text",
                );
                text.setAttribute("x", String(label.weekIndex * 14 + 30));
                text.setAttribute("y", "12");
                text.setAttribute("text-anchor", "start");
                text.setAttribute("class", "fill-slate-500 dark:fill-slate-400");
                text.setAttribute("font-size", "10px");
                text.setAttribute("font-weight", "500");
                text.textContent = label.name;
                svg.appendChild(text);
            });

            // Rebuild day rectangles
            const numWeeks = Math.ceil(days.length / 7);

            for (let weekIndex = 0; weekIndex < numWeeks; weekIndex++) {
                const g = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "g",
                );
                g.setAttribute("transform", `translate(${weekIndex * 14 + 30}, 24)`);

                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const dataIndex = weekIndex * 7 + dayIndex;
                    if (dataIndex >= days.length) break;

                    const dayData = days[dataIndex];
                    if (!dayData) continue;

                    const rect = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "rect",
                    );
                    rect.setAttribute("x", "0");
                    rect.setAttribute("y", String(dayIndex * 13));
                    rect.setAttribute("width", "12");
                    rect.setAttribute("height", "12");
                    rect.setAttribute("rx", "2");
                    rect.setAttribute("data-date", dayData.date);
                    rect.setAttribute("data-count", String(dayData.count));

                    rect.setAttribute(
                        "class",
                        `activity-day ${getColor(dayData.count)} ${dayData.count > 0 ? "cursor-pointer" : ""}`,
                    );

                    if (dayData.count > 0) {
                        rect.onclick = function () {
                            window.filterByDate(dayData.date);
                        };
                    }

                    g.appendChild(rect);
                }

                svg.appendChild(g);
            }
        };

        // Function to filter notes by date
        window.filterByDate = function(dateString) {
            const heatmap = document.getElementById("activity-heatmap");

            // If clicking the same date, clear the filter
            if (selectedDate === dateString) {
                selectedDate = null;
                heatmap?.classList.remove("is-filtering");
                // Clear any existing date filters
                const event = new CustomEvent("dateFilterChange", {
                    detail: { date: null },
                });
                window.dispatchEvent(event);
                // Reset visual feedback
                document
                    .querySelectorAll(".activity-day.selected")
                    .forEach((el) => {
                        el.classList.remove("selected");
                    });
                return;
            }

            selectedDate = dateString;
            heatmap?.classList.add("is-filtering");

            // Dispatch custom event to notify the main filtering system
            const event = new CustomEvent("dateFilterChange", {
                detail: { date: dateString },
            });
            window.dispatchEvent(event);

            // Add visual feedback to selected day
            document
                .querySelectorAll(".activity-day.selected")
                .forEach((el) => {
                    el.classList.remove("selected");
                });

            // Find and highlight the clicked day
            const clickedDay = document.querySelector(
                `[data-date="${dateString}"]`,
            );
            if (clickedDay) {
                clickedDay.classList.add("selected");
            }
        }

        // Tooltip logic
        const tooltip = document.getElementById("heatmap-tooltip");
        const svgElement = document.querySelector(".activity-heatmap-svg");

        function formatDate(dateStr) {
            const date = new Date(dateStr + "T00:00:00");
            return date.toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
                year: "numeric",
            });
        }

        if (svgElement && tooltip) {
            svgElement.addEventListener("mouseover", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    const count = parseInt(target.getAttribute("data-count") || "0");
                    const date = target.getAttribute("data-date");
                    const formattedDate = formatDate(date);

                    let text = "";
                    if (count === 0) text = `No contributions on ${formattedDate}`;
                    else if (count === 1) text = `1 contribution on ${formattedDate}`;
                    else text = `${count} contributions on ${formattedDate}`;

                    tooltip.textContent = text;

                    // Position relative to the rect
                    const rect = target.getBoundingClientRect();
                    tooltip.style.left = `${rect.left + rect.width / 2}px`;
                    tooltip.style.top = `${rect.top - 8}px`;
                    tooltip.style.transform = "translate(-50%, -100%)";

                    tooltip.classList.remove("hidden");
                }
            });

            svgElement.addEventListener("mouseout", (e) => {
                const target = e.target;
                if (target.tagName === "rect" && target.classList.contains("activity-day")) {
                    tooltip.classList.add("hidden");
                }
            });
        }

        // Add selected class styling
        const style = document.createElement("style");
        style.textContent = `
			.activity-day.selected {
				stroke: #10b981 !important;
				stroke-width: 2px !important;
			}
            #activity-heatmap.is-filtering .activity-day:not(.selected) {
                opacity: 0.3;
            }
            #activity-heatmap.is-filtering .activity-day.selected {
                opacity: 1;
            }
            #heatmap-tooltip::after {
                content: '';
                position: absolute;
                top: 100%;
                left: 50%;
                margin-left: -5px;
                border-width: 5px;
                border-style: solid;
                border-color: #0f172a transparent transparent transparent;
            }
            .dark #heatmap-tooltip::after {
                border-color: #1e293b transparent transparent transparent;
            }
		`;
        document.head.appendChild(style);
        // Initialize from attribute or default
        const initialYear = parseInt(document.documentElement.getAttribute('data-selected-year')) || year;
        if (initialYear !== year) {
            window.updateHeatmapYear(initialYear);
        }
    </script>
</div>
